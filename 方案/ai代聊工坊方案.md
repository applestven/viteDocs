##  技术方案 

以soul为基础 ， 写一款pc/安卓 聊天控制软件 

## 主要流程控制 以及回复
 
- 回复流程 
  1. 读取用户聊天页面信息 发现有红标未回复的消息
  2. 随机/按顺序 点击消息标进入聊天框
  3. 读取聊天框信息（这一部分 建立本地个人模型回复消息数据库） 读取前50条消息  调用ai接口获取回复
  4. 模拟打字反爬（前期复制黏贴）点击发送
  5. 等待 1-5秒 无回复 回到主页重新走回复流程  有回复 重新走本流程步骤3
   
  
- 打招呼流程
    1. 使用模型生成欢迎语 准备ai打招呼术语 或者 用户自定义术语 都随机选择一个打招呼
    2. 点击“星球”-点击“灵魂匹配”-“等待匹配成功（轮询）” - 会自动进入聊天窗口
    3.  开始聊天[拿到步骤1招呼] - 输入点击发送 - 等待 1-5秒 有回复 走[回复流程步骤3] 无回复 回到主页重新走打招呼流程 
   
    注意：1. 打招呼分两种 灵魂匹配（主动点击）  本地恋爱铃（本地招呼立即点开聊天框 ）

- 本地恋爱铃流程 
   1. 随机出现 恋爱铃 出现后立即点开  
   2. 调用[打招呼流程步骤1-步骤3] 


- 聊天流程优先级
  
  本地恋爱铃流程 〉 回复流程优先级 > 打招呼流程





## ai软件回复预设

1. 打招呼话术 不填默认ai随机（本地话术）
2. 用户人设信息填入（名字 爱好 等等）
3. 上传个人话术/恋爱技巧数据包 txt 文件  私人需求封装 （付费）


## 封装组件

进入聊天框后 点击输入-复制黏贴到输入框（或模拟打字）-点击发送动作 






## ✅ 整体架构流程
💬 聊天控制核心逻辑
主控调度流程：按优先级轮询处理三个模块：本地恋爱铃 > 未读消息回复 > 打招呼流程

每个流程解耦清晰，具备状态回退判断（是否收到回复），便于调试与扩展

🧠 AI 模型调用与数据
可支持本地/云端模型调用（如 OpenAI API、Claude、Gemini，也可以集成本地 LLM 如 Ollama）

支持用户上传自定义话术文本，结合 embedding 构建向量数据库实现私域知识增强（如：txt2vec + semantic search）

可以将用户人设（姓名、兴趣、口头禅）作为系统提示注入对话上下文中


## 技术难点考察 
1. 技术栈：electron + vue3 + ts + vite + tailwindcss 
2. soul软件只有app 移动端  是直接ocr识别等 点击 以及获取用户信息内容  还是 模拟器运行 抓包获取数据更合适  前者可以做更多的软件适配 
3. ocr识别最好能够走开源插件 打包进入electron 软件中  减少服务器ocr识别的次数


## 开发路线一：

第一阶段：基于模拟器+Mitmproxy实现核心功能

第二阶段：增加OCR方案实现真机支持

第三阶段：提供Xposed模块供高级用户选择

### 反检测策略

行为模式随机化：

随机操作间隔(1-5秒)

不规则打字速度模拟

随机浏览其他页面后再返回

设备指纹混淆：

随机修改模拟器设备信息

使用不同IP地址

模拟人类触摸轨迹

流量伪装：

混合正常浏览流量

随机延迟API调用

避免固定模式的消息发送




## 🔧 技术可行性分析
| 方式                     | 描述                                                                        | 优势                       | 局限性                                      |
| ------------------------ | --------------------------------------------------------------------------- | -------------------------- | ------------------------------------------- |
| 📱 **模拟器+抓包**        | 在安卓模拟器中运行 Soul，使用 Xposed/Hermes/Frida 抓取 API 数据或 Hook 控件 | 数据结构清晰、稳定性好     | Soul 有较强反作弊机制，封号风险             |
| 🧾 **OCR + 控件模拟点击** | 用 OCR 读取屏幕内容 + 控件定位（如 adb、uiautomator、ATX）+ 模拟点击/滑动   | 更安全、适配性强、支持真机 | UI 识别受控件位置、分辨率、颜色影响，需调优 |


🔹推荐方案：OCR 识别结合模拟点击 + 多机多分辨率适配，通过配置文件管理坐标偏移、颜色阈值、控件模板

2. 模拟打字
反爬建议：增加随机输入延迟 + 每次输入字符数量不同 + 粘贴/打字混合策略

可参考 Puppeteer 的 page.type() 模拟方案进行类似实现

3. Electron + Vue3 架构建议
前端管理面板使用 Vue3 + Tailwind 构建，具备设备状态展示、日志查看、话术配置、模型回复预览等功能

Electron 后端通过 child_process 或 Node.js HTTP client 控制模拟器/OCR服务

若集成 adb/uiautomator 方案，可将控制逻辑封装为 Node 插件模块

##  📦 模块封装

| 模块         | 功能描述                                             | 技术建议                                                                                                                               |
| ------------ | ---------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| OCR 模块     | 识别聊天框消息、红点标识、匹配按钮、恋爱铃等 UI 元素 | 使用 [PaddleOCR](https://github.com/PaddlePaddle/PaddleOCR) 或 [Tesseract](https://github.com/tesseract-ocr/tesseract)，结合图像预处理 |
| 控件操作模块 | 模拟点击、输入、滑动等                               | 安卓用 `adb shell input` + 坐标适配，或引入 [Airtest](https://airtest.netease.com/)                                                    |
| 聊天解析模块 | 获取聊天历史、格式化上下文                           | 文本分段+角色识别，便于输入 AI                                                                                                         |
| AI 回复模块  | 从消息上下文中生成合适回复                           | 支持 OpenAI / 自托管模型（llama.cpp / localollama）+ 知识包融合                                                                        |
| 日志记录模块 | 操作轨迹与消息存档                                   | JSON 文件/SQLite 存储，支持前端面板展示                                                                                                |
| 自动调度模块 | 主流程调度与优先级管理                               | 状态机设计 + 任务队列控制流程稳定性                                                                                                    |

## 📌 延展（中后期功能）
多账号并发支持：每个账号运行在独立模拟器进程中，调度器统一管理任务分发

行为数据回传与训练：采集“聊天成功率”、“对方回复率”等数据辅助微调模型

防检测策略模块：定期变更打字速率、聊天模板轮换，防止行为模式化

任务脚本可视化编辑器：让用户自定义流程控制逻辑、触发条件等（类似自动化工具）